# ============================================================
# Origin Axiom — Phase 2 Snakemake Workflow
#
# Canonical rule: one rule -> one canonical artifact (figure PDF or paper PDF).
# All figures must be generated by Snakemake (no manual figures).
#
# Robust when invoked from:
#   (a) inside phase2/:     snakemake -c 1
#   (b) repo root:         snakemake -c 1 -s phase2/workflow/Snakefile
# ============================================================

from __future__ import annotations

import json
from pathlib import Path
from datetime import datetime

# ------------------------------------------------------------
# Locate Phase 2 root relative to this Snakefile
# ------------------------------------------------------------
PHASE2_DIR = Path(workflow.basedir).resolve().parent
SRC_DIR    = PHASE2_DIR / "src"
CFG_PATH   = PHASE2_DIR / "config" / "phase2.yaml"

configfile: str(CFG_PATH)
CONFIG = config

# ------------------------------------------------------------
# Helpers
# ------------------------------------------------------------
def utc_timestamp() -> str:
    return datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")


RUN_BASE = PHASE2_DIR / CONFIG["outputs"]["run_dir"]   # e.g. phase2/outputs/runs
FIG_BASE = PHASE2_DIR / CONFIG["outputs"]["fig_dir"]   # e.g. phase2/outputs/figures
BUNDLE_DIR = PHASE2_DIR / "outputs" / "paper_bundle"

# Use absolute PYTHONPATH for robustness
PY = f'PYTHONPATH="{SRC_DIR}" python'


def _stable_run_id(default_prefix: str, runid_file: Path) -> str:
    """
    Keep run_id stable across snakemake invocations:

    - If runid_file exists, reuse it (prevents rerun due to param changes).
    - Otherwise generate a timestamped one.
    """
    if runid_file.exists():
        txt = runid_file.read_text(encoding="utf-8").strip()
        if txt:
            return txt
    return f"{default_prefix}_{utc_timestamp()}"


# Canonical figure names (must match paper + CLAIMS.md)
FIGURES = [
    "figA_mode_sum_residual.pdf",
    "figB_scaling_epsilon.pdf",
    "figC_scaling_cutoff.pdf",
    "figD_scaling_modes.pdf",
    "figE_frw_comparison.pdf",
]

RUNID_FILES = [
    str(FIG_BASE / "figA_mode_sum_residual.run_id.txt"),
    str(FIG_BASE / "figB_scaling_epsilon.run_id.txt"),
    str(FIG_BASE / "figC_scaling_cutoff.run_id.txt"),
    str(FIG_BASE / "figD_scaling_modes.run_id.txt"),
    str(FIG_BASE / "figE_frw_comparison.run_id.txt"),
]

# ------------------------------------------------------------
# Default target
# ------------------------------------------------------------
rule all:
    input:
        expand(str(FIG_BASE / "{f}"), f=FIGURES),
        str(PHASE2_DIR / "paper" / "main.pdf")

# ============================================================
# FIGURE A — Mode-sum residual (Claim 2.1)
# ============================================================
rule figA_mode_sum_residual:
    output:
        fig=str(FIG_BASE / "figA_mode_sum_residual.pdf"),
        runid=str(FIG_BASE / "figA_mode_sum_residual.run_id.txt"),
    params:
        run_id=lambda wc, output: _stable_run_id("figA_mode_sum_residual", Path(output.runid)),
    shell:
        r'''
        set -euo pipefail
        mkdir -p "{RUN_BASE}" "{FIG_BASE}"

        {PY} -m phase2.modes.run_mode_sum \
            --config "{CFG_PATH}" \
            --task residual \
            --run-id "{params.run_id}"

        cp "{RUN_BASE}/{params.run_id}/figures/residual.pdf" "{output.fig}"
        echo "{params.run_id}" > "{output.runid}"
        '''

# ============================================================
# FIGURE B — Scaling with epsilon (Claim 2.2)
# ============================================================
rule figB_scaling_epsilon:
    output:
        fig=str(FIG_BASE / "figB_scaling_epsilon.pdf"),
        runid=str(FIG_BASE / "figB_scaling_epsilon.run_id.txt"),
    params:
        run_id=lambda wc, output: _stable_run_id("figB_scaling_epsilon", Path(output.runid)),
        sweep="epsilon",
        produced="scaling_epsilon.pdf",
    shell:
        r'''
        set -euo pipefail
        mkdir -p "{RUN_BASE}" "{FIG_BASE}"

        {PY} -m phase2.modes.run_sweep \
            --config "{CFG_PATH}" \
            --sweep "{params.sweep}" \
            --run-id "{params.run_id}"

        cp "{RUN_BASE}/{params.run_id}/figures/{params.produced}" "{output.fig}"
        echo "{params.run_id}" > "{output.runid}"
        '''

# ============================================================
# FIGURE C — Scaling with cutoff (Claim 2.2)
# ============================================================
rule figC_scaling_cutoff:
    output:
        fig=str(FIG_BASE / "figC_scaling_cutoff.pdf"),
        runid=str(FIG_BASE / "figC_scaling_cutoff.run_id.txt"),
    params:
        run_id=lambda wc, output: _stable_run_id("figC_scaling_cutoff", Path(output.runid)),
        sweep="cutoff",
        produced="scaling_cutoff.pdf",
    shell:
        r'''
        set -euo pipefail
        mkdir -p "{RUN_BASE}" "{FIG_BASE}"

        {PY} -m phase2.modes.run_sweep \
            --config "{CFG_PATH}" \
            --sweep "{params.sweep}" \
            --run-id "{params.run_id}"

        cp "{RUN_BASE}/{params.run_id}/figures/{params.produced}" "{output.fig}"
        echo "{params.run_id}" > "{output.runid}"
        '''

# ============================================================
# FIGURE D — Scaling with number of modes (Claim 2.2)
# ============================================================
rule figD_scaling_modes:
    output:
        fig=str(FIG_BASE / "figD_scaling_modes.pdf"),
        runid=str(FIG_BASE / "figD_scaling_modes.run_id.txt"),
    params:
        run_id=lambda wc, output: _stable_run_id("figD_scaling_modes", Path(output.runid)),
        sweep="n_modes",
        produced="scaling_modes.pdf",
    shell:
        r'''
        set -euo pipefail
        mkdir -p "{RUN_BASE}" "{FIG_BASE}"

        {PY} -m phase2.modes.run_sweep \
            --config "{CFG_PATH}" \
            --sweep "{params.sweep}" \
            --run-id "{params.run_id}"

        cp "{RUN_BASE}/{params.run_id}/figures/{params.produced}" "{output.fig}"
        echo "{params.run_id}" > "{output.runid}"
        '''

# ============================================================
# FIGURE E — FRW cosmology (Claim 2.3)
# ============================================================
rule figE_frw_comparison:
    output:
        fig=str(FIG_BASE / "figE_frw_comparison.pdf"),
        runid=str(FIG_BASE / "figE_frw_comparison.run_id.txt"),
    params:
        run_id=lambda wc, output: _stable_run_id("figE_frw_comparison", Path(output.runid)),
    shell:
        r'''
        set -euo pipefail
        mkdir -p "{RUN_BASE}" "{FIG_BASE}"

        {PY} -m phase2.cosmology.run_frw \
            --config "{CFG_PATH}" \
            --run-id "{params.run_id}"

        cp "{RUN_BASE}/{params.run_id}/figures/frw_comparison.pdf" "{output.fig}"
        echo "{params.run_id}" > "{output.runid}"
        '''

# ============================================================
# PAPER BUNDLE (for writing + review packaging)
# ============================================================
rule paper_bundle:
    """
    Collect everything needed to write/review the Phase 2 paper in one folder:

      outputs/paper_bundle/
        figures/*.pdf
        config/phase2.yaml
        runs/<run_id>/... (full provenance for each canonical figure)
        run_index.json
    """
    input:
        figs=expand(str(FIG_BASE / "{f}"), f=FIGURES),
        runids=RUNID_FILES,
        cfg=str(CFG_PATH),
    output:
        index=str(BUNDLE_DIR / "run_index.json"),
    run:
        BUNDLE_DIR.mkdir(parents=True, exist_ok=True)

        # Copy canonical figures
        (BUNDLE_DIR / "figures").mkdir(parents=True, exist_ok=True)
        for fig in input.figs:
            src = Path(fig)
            dst = BUNDLE_DIR / "figures" / src.name
            dst.write_bytes(src.read_bytes())

        # Copy config
        (BUNDLE_DIR / "config").mkdir(parents=True, exist_ok=True)
        cfg_src = Path(input.cfg)
        (BUNDLE_DIR / "config" / cfg_src.name).write_bytes(cfg_src.read_bytes())

        # Copy full run directories for each figure
        run_map = {}
        for runid_path in input.runids:
            p = Path(runid_path)
            fig_key = p.name.replace(".run_id.txt", "")
            run_id = p.read_text(encoding="utf-8").strip()
            run_map[fig_key] = run_id

            src_dir = RUN_BASE / run_id
            dst_dir = BUNDLE_DIR / "runs" / run_id
            dst_dir.parent.mkdir(parents=True, exist_ok=True)

            if not src_dir.exists():
                raise RuntimeError(f"Expected run dir missing: {src_dir}")

            # recursive copy (python only)
            for item in src_dir.rglob("*"):
                rel = item.relative_to(src_dir)
                outp = dst_dir / rel
                if item.is_dir():
                    outp.mkdir(parents=True, exist_ok=True)
                else:
                    outp.parent.mkdir(parents=True, exist_ok=True)
                    outp.write_bytes(item.read_bytes())

        index = {
            "phase": 2,
            "phase2_dir": str(PHASE2_DIR),
            "figures": FIGURES,
            "canonical_fig_dir": str(FIG_BASE),
            "canonical_run_dir": str(RUN_BASE),
            "run_ids": run_map,
        }
        Path(output.index).write_text(json.dumps(index, indent=2), encoding="utf-8")

# ============================================================
# PAPER
# ============================================================
rule paper:
    input:
        figs=expand(str(FIG_BASE / "{f}"), f=FIGURES)
    output:
        str(PHASE2_DIR / "paper" / "main.pdf")
    shell:
        r'''
        set -euo pipefail
        cd "{PHASE2_DIR}/paper" && latexmk -pdf -interaction=nonstopmode -halt-on-error main.tex
        '''