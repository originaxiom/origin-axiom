#!/usr/bin/env python3
"""
R22: theta_star FRW background vs ΛCDM backbone

This rung compares the FRW models generated by the effective-vacuum bridge
(evaluated on a theta_star grid) to a fixed reference ΛCDM cosmology with
(Ω_m, Ω_Λ) = (0.3, 0.7) and the same H0 as used in the scan. We work purely
at the background level: age t0 and dimensionless luminosity distances
d_L(z)/(c/H0) at a small set of redshifts.

Inputs
------
- data/processed/effective_vacuum_theta_frw_scan.npz
    Keys (as produced by the R12 scan script):
      * theta_scan
      * omega_lambda_scan
      * omega_m_scan
      * t0_H0_scan
      * t0_gyr_scan
      * q0_scan
      * dL_z03_scan
      * dL_z05_scan
      * dL_z10_scan
      * theta_min_band, theta_max_band
      * H0_KM_S_MPC
      * theta_fid, delta_E_fid, k_scale, omega_target

Outputs
-------
- data/processed/theta_star_lcdm_background_residuals.npz

    Stored arrays:
      * theta_scan
      * omega_lambda_scan
      * omega_m_scan
      * t0_gyr_scan
      * q0_scan
      * dL_z03_scan, dL_z05_scan, dL_z10_scan
      * corridor_mask   (boolean, same criteria as R13)
      * t0_ref_gyr
      * dL_ref_z03, dL_ref_z05, dL_ref_z10
      * delta_t0_over_ref        (t0/t0_ref - 1)
      * delta_dL_z03_frac        ((dL - dL_ref)/dL_ref)
      * delta_dL_z05_frac
      * delta_dL_z10_frac
      * chi2_bg                  (simple background mismatch score)

The script also prints band-level and corridor-level summary statistics.
"""

from __future__ import annotations

import numpy as np


SCAN_PATH = "data/processed/effective_vacuum_theta_frw_scan.npz"
OUTPUT_PATH = "data/processed/theta_star_lcdm_background_residuals.npz"


def hubble_time_gyr(H0_km_s_Mpc: float) -> float:
    """
    Return the Hubble time 1/H0 in Gyr, given H0 in km/s/Mpc.
    """
    # Convert H0 to s^-1
    Mpc_in_m = 3.0856775814913673e22  # m
    H0_si = H0_km_s_Mpc * 1000.0 / Mpc_in_m  # s^-1
    t_H_s = 1.0 / H0_si
    seconds_per_year = 365.25 * 24.0 * 3600.0
    t_H_gyr = t_H_s / (seconds_per_year * 1.0e9)
    return t_H_gyr


def age_lcdm_gyr(omega_m: float, omega_lambda: float, H0_km_s_Mpc: float) -> float:
    """
    Compute the age of a flat ΛCDM universe (Ω_m, Ω_Λ) in Gyr
    using the standard integral t0 = ∫ da / (a H(a)), with
    H(a)/H0 = sqrt(Ω_m a^-3 + Ω_Λ).
    """
    a_min = 1.0e-4
    a_max = 1.0
    a_grid = np.linspace(a_min, a_max, 4000)
    E = np.sqrt(omega_m * a_grid**-3 + omega_lambda)
    integrand = 1.0 / (a_grid * E)
    t0_H0 = np.trapz(integrand, a_grid)  # dimensionless t0 * H0
    t_H_gyr = hubble_time_gyr(H0_km_s_Mpc)
    return t0_H0 * t_H_gyr


def dL_dimensionless(omega_m: float, omega_lambda: float, z: float) -> float:
    """
    Dimensionless luminosity distance d_L(z)/(c/H0) for a flat ΛCDM cosmology
    with (Ω_m, Ω_Λ) at a given redshift z.

    We compute the comoving distance in units of c/H0:
      chi(z) = ∫_0^z dz' / E(z'),  E(z') = sqrt(Ω_m (1+z')^3 + Ω_Λ)
    and then d_L = (1+z) * chi.
    """
    if z == 0.0:
        return 0.0

    z_grid = np.linspace(0.0, z, 400)
    E = np.sqrt(omega_m * (1.0 + z_grid) ** 3 + omega_lambda)
    integrand = 1.0 / E
    chi = np.trapz(integrand, z_grid)
    dL = (1.0 + z) * chi
    return float(dL)


def main() -> None:
    print("=== R22: theta_star FRW background vs ΛCDM backbone ===")

    data = np.load(SCAN_PATH)

    theta = data["theta_scan"]
    omega_lambda = data["omega_lambda_scan"]
    omega_m = data["omega_m_scan"]
    t0_gyr = data["t0_gyr_scan"]
    q0 = data["q0_scan"]
    dL_z03 = data["dL_z03_scan"]
    dL_z05 = data["dL_z05_scan"]
    dL_z10 = data["dL_z10_scan"]

    theta_min_band = float(data["theta_min_band"])
    theta_max_band = float(data["theta_max_band"])
    H0_km_s_Mpc = float(data["H0_KM_S_MPC"])
    theta_fid = float(data["theta_fid"])
    omega_target = float(data["omega_target"])

    print(f"Loaded FRW scan from {SCAN_PATH}")
    print(f"  theta band        : {theta_min_band:.3f} -> {theta_max_band:.3f} rad")
    print(f"  Omega_Lambda band : {omega_lambda.min():.3f} -> {omega_lambda.max():.3f}")
    print(f"  t0 band (Gyr)     : {t0_gyr.min():.2f} -> {t0_gyr.max():.2f}")
    print(f"  q0 band           : {q0.min():.3f} -> {q0.max():.3f}")
    print(f"  H0                : {H0_km_s_Mpc:.1f} km s^-1 Mpc^-1")
    print(f"  theta_fid         : {theta_fid:.3f} rad (target Omega_Lambda ~ {omega_target:.3f})")
    print()

    # ------------------------------------------------------------------
    # Reference ΛCDM backbone
    # ------------------------------------------------------------------
    omega_m_ref = 0.3
    omega_lambda_ref = 0.7

    t0_ref_gyr = age_lcdm_gyr(omega_m_ref, omega_lambda_ref, H0_km_s_Mpc)
    dL_ref_z03 = dL_dimensionless(omega_m_ref, omega_lambda_ref, 0.3)
    dL_ref_z05 = dL_dimensionless(omega_m_ref, omega_lambda_ref, 0.5)
    dL_ref_z10 = dL_dimensionless(omega_m_ref, omega_lambda_ref, 1.0)

    # Reference deceleration parameter
    q0_ref = 0.5 * omega_m_ref - omega_lambda_ref

    print("Reference ΛCDM backbone (internal):")
    print(f"  (Omega_m, Omega_Lambda) = ({omega_m_ref:.3f}, {omega_lambda_ref:.3f})")
    print(f"  t0_ref                  = {t0_ref_gyr:.3f} Gyr")
    print(f"  q0_ref                  = {q0_ref:.3f}")
    print(f"  dL_ref(z)/(c/H0):")
    print(f"    z=0.3 : {dL_ref_z03:.4f}")
    print(f"    z=0.5 : {dL_ref_z05:.4f}")
    print(f"    z=1.0 : {dL_ref_z10:.4f}")
    print()

    # ------------------------------------------------------------------
    # Residuals vs reference backbone
    # ------------------------------------------------------------------
    # Age residuals (fractional)
    delta_t0_over_ref = t0_gyr / t0_ref_gyr - 1.0

    # Distance residuals (fractional)
    delta_dL_z03_frac = (dL_z03 - dL_ref_z03) / dL_ref_z03
    delta_dL_z05_frac = (dL_z05 - dL_ref_z05) / dL_ref_z05
    delta_dL_z10_frac = (dL_z10 - dL_ref_z10) / dL_ref_z10

    # Simple background mismatch score: chi^2 over the three distance points
    sigma_frac = 0.05  # illustrative 5% tolerance at each z
    chi2_bg = (
        (delta_dL_z03_frac / sigma_frac) ** 2
        + (delta_dL_z05_frac / sigma_frac) ** 2
        + (delta_dL_z10_frac / sigma_frac) ** 2
    )

    # ------------------------------------------------------------------
    # Observable corridor mask (reuse R13 criteria)
    # ------------------------------------------------------------------
    corridor_mask = (
        (omega_lambda >= 0.60)
        & (omega_lambda <= 0.80)
        & (t0_gyr >= 12.0)
        & (t0_gyr <= 15.0)
        & (q0 < 0.0)
    )

    n_total = theta.size
    n_corridor = int(corridor_mask.sum())

    print("Observable corridor selection (as in R13):")
    print("  Criteria:")
    print("    0.60 <= Omega_Lambda <= 0.80")
    print("    12.0 <= t0 <= 15.0 Gyr")
    print("    q0 < 0")
    print(f"  Selected {n_corridor} / {n_total} samples ({100.0 * n_corridor / n_total:.1f}%)")
    print()

    # ------------------------------------------------------------------
    # Band-level summary
    # ------------------------------------------------------------------
    def summarize_residuals(mask: np.ndarray, label: str) -> None:
        idx = np.where(mask)[0]
        if idx.size == 0:
            print(f"[{label}] No samples selected.")
            return

        abs_dt = np.abs(delta_t0_over_ref[mask])
        abs_d03 = np.abs(delta_dL_z03_frac[mask])
        abs_d05 = np.abs(delta_dL_z05_frac[mask])
        abs_d10 = np.abs(delta_dL_z10_frac[mask])

        def pct(x: np.ndarray) -> tuple[float, float, float]:
            return (
                100.0 * np.min(x),
                100.0 * np.median(x),
                100.0 * np.max(x),
            )

        dt_min, dt_med, dt_max = pct(abs_dt)
        d03_min, d03_med, d03_max = pct(abs_d03)
        d05_min, d05_med, d05_max = pct(abs_d05)
        d10_min, d10_med, d10_max = pct(abs_d10)

        print(f"[{label}] residuals vs ΛCDM backbone (absolute, in %):")
        print(f"  |Δt0/t0_ref| : min/med/max = {dt_min:.2f} / {dt_med:.2f} / {dt_max:.2f}")
        print(f"  |ΔdL(z=0.3)| : min/med/max = {d03_min:.2f} / {d03_med:.2f} / {d03_max:.2f}")
        print(f"  |ΔdL(z=0.5)| : min/med/max = {d05_min:.2f} / {d05_med:.2f} / {d05_max:.2f}")
        print(f"  |ΔdL(z=1.0)| : min/med/max = {d10_min:.2f} / {d10_med:.2f} / {d10_max:.2f}")
        print()

    summarize_residuals(np.ones_like(theta, dtype=bool), "Full theta_star band")
    summarize_residuals(corridor_mask, "Observable corridor")

    # ------------------------------------------------------------------
    # Best-matching theta_star slice (min chi^2) within corridor
    # ------------------------------------------------------------------
    if n_corridor > 0:
        chi2_corr = np.where(corridor_mask, chi2_bg, np.inf)
        best_idx = int(np.argmin(chi2_corr))
        print("Best-matching theta_star slice within corridor (min chi^2_bg):")
        print(f"  theta_best       = {theta[best_idx]:.3f} rad")
        print(
            f"  (Omega_m, Omega_Lambda) = "
            f"({omega_m[best_idx]:.3f}, {omega_lambda[best_idx]:.3f})"
        )
        print(f"  t0(theta_best)   = {t0_gyr[best_idx]:.3f} Gyr")
        print(f"  q0(theta_best)   = {q0[best_idx]:.3f}")
        print("  Fractional distance residuals vs reference ΛCDM:")
        print(
            f"    ΔdL(z=0.3)/dL_ref = {delta_dL_z03_frac[best_idx]:+.3e} "
            f"({100.0*delta_dL_z03_frac[best_idx]:+.2f} %)"
        )
        print(
            f"    ΔdL(z=0.5)/dL_ref = {delta_dL_z05_frac[best_idx]:+.3e} "
            f"({100.0*delta_dL_z05_frac[best_idx]:+.2f} %)"
        )
        print(
            f"    ΔdL(z=1.0)/dL_ref = {delta_dL_z10_frac[best_idx]:+.3e} "
            f"({100.0*delta_dL_z10_frac[best_idx]:+.2f} %)"
        )
        print(f"  chi2_bg(theta_best) = {chi2_bg[best_idx]:.3f}")
        print()
    else:
        print("No samples in the observable corridor; skipping best-slice summary.\n")

    # ------------------------------------------------------------------
    # Save residuals to disk
    # ------------------------------------------------------------------
    np.savez(
        OUTPUT_PATH,
        theta_scan=theta,
        omega_lambda_scan=omega_lambda,
        omega_m_scan=omega_m,
        t0_gyr_scan=t0_gyr,
        q0_scan=q0,
        dL_z03_scan=dL_z03,
        dL_z05_scan=dL_z05,
        dL_z10_scan=dL_z10,
        corridor_mask=corridor_mask,
        t0_ref_gyr=t0_ref_gyr,
        dL_ref_z03=dL_ref_z03,
        dL_ref_z05=dL_ref_z05,
        dL_ref_z10=dL_ref_z10,
        delta_t0_over_ref=delta_t0_over_ref,
        delta_dL_z03_frac=delta_dL_z03_frac,
        delta_dL_z05_frac=delta_dL_z05_frac,
        delta_dL_z10_frac=delta_dL_z10_frac,
        chi2_bg=chi2_bg,
        omega_target=omega_target,
        theta_fid=theta_fid,
        H0_KM_S_MPC=H0_km_s_Mpc,
    )

    print(f"Saved residuals to {OUTPUT_PATH}")


if __name__ == "__main__":
    main()